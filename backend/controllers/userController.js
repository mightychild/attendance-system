const User = require('../models/User');
const AppError = require('../utils/AppError');
const catchAsync = require('../utils/catchAsync');
const { signQRToken, verifyQRToken } = require('../utils/qrToken');
const jwt = require('jsonwebtoken');

// @desc    Get all users (with filtering and pagination)
// @route   GET /api/admin/users
// @access  Private (Super Admin only)
exports.getAllUsers = catchAsync(async (req, res, next) => {
  const { role, page = 1, limit = 10, search } = req.query;
  
  // Build query
  let query = {};
  
  // Filter by role if provided
  if (role && role !== 'all') {
    query.role = role;
  }
  
  // Search functionality (by name, email, or universityId)
  if (search) {
    query.$or = [
      { firstName: { $regex: search, $options: 'i' } },
      { lastName: { $regex: search, $options: 'i' } },
      { email: { $regex: search, $options: 'i' } },
      { universityId: { $regex: search, $options: 'i' } }
    ];
  }

  const users = await User.find(query)
    .select('-password -qrSecret') // Never send passwords or QR secrets
    .sort({ createdAt: -1 })
    .limit(limit * 1)
    .skip((page - 1) * limit);

  const total = await User.countDocuments(query);

  res.status(200).json({
    status: 'success',
    results: users.length,
    total,
    totalPages: Math.ceil(total / limit),
    currentPage: page,
    data: {
      users
    }
  });
});

// @desc    Create a new user (typically for creating lecturers)
// @route   POST /api/admin/users
// @access  Private (Super Admin only)
exports.createUser = catchAsync(async (req, res, next) => {
  // Extract ONLY the fields we allow from req.body
  const { firstName, lastName, email, universityId, password, role } = req.body;

  // Validation
  if (!firstName || !lastName || !email || !password || !role) {
    return next(new AppError('Please provide all required fields.', 400));
  }

  // Check if email already exists
  const existingUser = await User.findOne({ email });
  if (existingUser) {
    return next(new AppError('A user with this email already exists.', 400));
  }

  // For lecturers/students, check if universityId is unique for that role
  if (universityId && role !== 'super-admin') {
    const idExists = await User.isUniversityIdTaken(universityId, role);
    if (idExists) {
      return next(new AppError(`This ${role} ID is already in use.`, 400));
    }
  }

  // Create the new user - ONLY with the explicitly allowed fields
  // QR secret will be auto-generated by the pre-save hook
  const newUser = await User.create({
    firstName,
    lastName,
    email,
    universityId: role !== 'super-admin' ? universityId : undefined,
    password,
    role
  });

  // Remove password from response
  newUser.password = undefined;

  res.status(201).json({
    status: 'success',
    data: {
      user: newUser
    }
  });
});

// @desc    Update user status (activate/deactivate)
// @route   PATCH /api/admin/users/:id/status
// @access  Private (Super Admin only)
exports.updateUserStatus = catchAsync(async (req, res, next) => {
  const { id } = req.params;
  // Extract ONLY the field we allow from req.body
  const { isActive } = req.body;

  const user = await User.findByIdAndUpdate(
    id,
    { isActive }, // Only update the isActive field
    { new: true, runValidators: true }
  ).select('-password -qrSecret');

  if (!user) {
    return next(new AppError('No user found with that ID.', 404));
  }

  res.status(200).json({
    status: 'success',
    data: {
      user
    }
  });
});

// @desc    Update user profile (name and phone number)
// @route   PATCH /api/users/:id/profile
// @access  Private (User owns the profile or Admin)
exports.updateUserProfile = catchAsync(async (req, res, next) => {
  const { id } = req.params;
  const { firstName, lastName, phoneNumber } = req.body;

  // Check if user is updating their own profile or is admin
  if (req.user._id.toString() !== id && req.user.role !== 'super-admin') {
    return next(new AppError('You can only update your own profile', 403));
  }

  // Build update object with only the provided fields
  const updateData = {};
  if (firstName !== undefined) updateData.firstName = firstName;
  if (lastName !== undefined) updateData.lastName = lastName;
  if (phoneNumber !== undefined) updateData.phoneNumber = phoneNumber;

  const user = await User.findByIdAndUpdate(
    id,
    updateData,
    { new: true, runValidators: true }
  ).select('-password -qrSecret');

  if (!user) {
    return next(new AppError('User not found', 404));
  }

  res.status(200).json({
    status: 'success',
    data: {
      user
    }
  });
});

// @desc    Delete a user
// @route   DELETE /api/admin/users/:id
// @access  Private (Super Admin only)
exports.deleteUser = catchAsync(async (req, res, next) => {
  const { id } = req.params;

  const user = await User.findByIdAndDelete(id);

  if (!user) {
    return next(new AppError('No user found with that ID.', 404));
  }

  res.status(204).json({
    status: 'success',
    data: null
  });
});

// @desc    Get user statistics
// @route   GET /api/admin/users/stats
// @access  Private (Super Admin)
exports.getUserStats = catchAsync(async (req, res, next) => {
  try {
    const totalUsers = await User.countDocuments();
    const superAdmins = await User.countDocuments({ role: 'super-admin', isActive: true });
    const lecturers = await User.countDocuments({ role: 'lecturer', isActive: true });
    const students = await User.countDocuments({ role: 'student', isActive: true });
    const inactiveUsers = await User.countDocuments({ isActive: false });

    res.status(200).json({
      status: 'success',
      data: {
        totalUsers,
        superAdmins,
        lecturers,
        students,
        inactiveUsers
      }
    });
  } catch (error) {
    console.error('User stats error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to fetch user statistics'
    });
  }
});



// @desc    Get current user's QR code
// @route   GET /api/students/me/qrcode
// @access  Private (Any user with universityId)
exports.getMyQRCode = catchAsync(async (req, res, next) => {
  // Check if user has a university ID
  if (!req.user.universityId) {
    return next(new AppError('You need a university ID to generate a QR code', 400));
  }

  // Get current user with QR secret
  const currentUser = await User.findById(req.user._id).select('+qrSecret');
  if (!currentUser) {
    return next(new AppError('User not found', 404));
  }

  // Generate QR token using user's specific secret
  const qrToken = signQRToken(currentUser._id.toString(), currentUser.qrSecret);

  const qrData = {
    token: qrToken
  };

  const qrCodeString = JSON.stringify(qrData);

  res.status(200).json({
    status: 'success',
    data: {
      qrCode: qrCodeString,
      user: {
        _id: currentUser._id,
        firstName: currentUser.firstName,
        lastName: currentUser.lastName,
        universityId: currentUser.universityId,
        role: currentUser.role
      }
    }
  });
});

// @desc    Get user's QR code data
// @route   GET /api/students/:userId/qrcode
// @access  Private (User owns it or Lecturer/Admin for verification)
exports.getStudentQRCode = catchAsync(async (req, res, next) => {
  const { userId } = req.params;

  // Check if user has permission - allow if user is the owner or is admin/lecturer
  if (req.user.role !== 'super-admin' && req.user.role !== 'lecturer' && req.user._id.toString() !== userId) {
    return next(new AppError('You do not have permission to access this QR code', 403));
  }

  // Find user with QR secret
  const user = await User.findById(userId).select('+qrSecret');
  if (!user || !user.universityId) {
    return next(new AppError('User not found or does not have a university ID', 404));
  }

  // Generate QR token using user's specific secret
  const qrToken = signQRToken(user._id.toString(), user.qrSecret);

  const qrData = {
    token: qrToken
  };

  const qrCodeString = JSON.stringify(qrData);

  res.status(200).json({
    status: 'success',
    data: {
      qrCode: qrCodeString,
      user: {
        _id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        universityId: user.universityId,
        role: user.role
      }
    }
  });
});

// @desc    Verify QR code and get user info
// @route   POST /api/students/verify-qr
// @access  Private (Lecturer/Admin)
exports.verifyQRCode = catchAsync(async (req, res, next) => {
  const { qrCodeData } = req.body;

  if (!qrCodeData) {
    return next(new AppError('QR code data is required', 400));
  }

  // Parse QR code data
  let qrData;
  try {
    qrData = JSON.parse(qrCodeData);
  } catch (error) {
    return next(new AppError('Invalid QR code format', 400));
  }

  if (!qrData.token) {
    return next(new AppError('Invalid QR code data: Token missing', 400));
  }

  // Verify QR token
  const verificationResult = verifyQRToken(qrData.token);

  if (!verificationResult.valid) {
    const message = verificationResult.expired ? 
      'QR code has expired. Please generate a new one.' : 
      'Invalid QR code signature.';
    return next(new AppError(message, 400));
  }

  // Find user by ID from token
  const user = await User.findById(verificationResult.decoded.id);
  if (!user || !user.universityId || !user.isActive) {
    return next(new AppError('User not found or inactive', 404));
  }

  res.status(200).json({
    status: 'success',
    data: {
      user: {
        _id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        universityId: user.universityId,
        email: user.email,
        role: user.role
      }
    }
  });
});